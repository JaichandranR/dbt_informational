change control process

Explanation for Point 1 and Point 2
Point 1: Source Control
This focuses on managing the journey of source-controlled items from their inception to production deployment. Here is a step-by-step breakdown:

Code Development:

Developers create or modify code in their local environment.
Changes are committed to a version control system (e.g., Git) using feature branches to isolate work.
Code Review:

The committed code undergoes peer review through pull/merge requests. This ensures adherence to coding standards, best practices, and functionality correctness.
Reviewers suggest changes or approve the code.
Testing and Validation:

Automated tests (unit tests, integration tests) are triggered via Continuous Integration (CI) pipelines.
If tests fail, the code does not proceed further and must be fixed.
Merging:

Once approved, the code is merged into a main or staging branch (e.g., main, develop).
Additional CI jobs may run, ensuring the integrity of the branch.
Build and Artifact Creation:

The merged code is packaged into deployable artifacts (e.g., Docker images, JAR files).
These artifacts are stored in a repository (e.g., JFrog, Nexus).
Deployment to Environments:

Artifacts are deployed to pre-production environments (e.g., QA, UAT) for further testing.
Each environment may have dedicated deployment pipelines controlled by infrastructure as code (e.g., Terraform, Helm charts).
Production Deployment:

After passing UAT, the code is deployed to production.
Deployment is often automated and monitored through CI/CD tools (e.g., Jenkins, GitHub Actions).
Post-Deployment Monitoring:

Metrics and logs are analyzed to ensure the system is functioning as expected.
Rollback mechanisms are in place for quick recovery if issues arise.
Point 2: Configuration and Code Changes
This emphasizes the management and tracking of configuration and code changes across environments, particularly in production. Here's how itâ€™s managed:

Change Identification:

Developers or system engineers document the intended configuration and code changes.
Examples include schema updates, feature toggles, or changes to configuration files.
Impact Analysis:

The potential impact of changes is analyzed on dependent systems and services.
Risks are identified and mitigated (e.g., testing in a staging environment).
Versioning:

Configuration changes are version-controlled alongside code (e.g., application.yaml stored in Git).
This ensures traceability and rollback capabilities.
Testing Configuration Changes:

Automated tests validate the behavior of configuration changes.
For schema changes, database migration scripts are tested in pre-production environments.
Approval Process:

Changes go through an approval workflow, typically involving Change Advisory Boards (CABs) or automated policies.
Documentation of the change (e.g., in a ticketing system like Jira) ensures transparency.
Deployment Process:

Configuration changes are deployed via the same pipelines as code, ensuring consistency.
Infrastructure automation tools (e.g., Ansible, Helm) are often used to apply changes.
Validation Post-Deployment:

Functional and regression testing confirm the success of the configuration updates.
Teams monitor metrics for potential issues.
Schema Changes Specifics:

For database schema changes, ensure backward compatibility:
Step 1: Add non-breaking changes (e.g., new columns).
Step 2: Deploy application changes utilizing the new schema.
Step 3: Remove deprecated elements if necessary in a subsequent release.
By managing both code and configuration changes systematically, organizations minimize risks while ensuring changes are properly tested and tracked throughout their lifecycle.
